## Abstract Data Type vs. Data Structure
> 抽象数据类型 = 数据结构 + 定义在该模型上的一组操作
>>* 抽象定义
>>* 外部的逻辑特性
>>* 操作&语义
>>* 一种定义
>>* 不考虑时间复杂度
>>* 不涉及数据的存储方式

> 数据结构 = 基于某种特定语言，实现ADT的一整套算法
>>* 具体实现
>>* 内部的表示与实现
>>* 完整的算法
>>* 多种实现
>>* 与复杂度密切相关
>>* 要考虑数据的具体存储机制

## 静态空间管理
`上溢`:
数组空间不足以存放所有的元素，尽管此时系统仍然有足够的空间

`下溢`:
数组空间中的元素寥寥无几，装填因子 $\lambda = size/capacity \ll 50%$

## 动态空间管理
在即将发生上溢时，**适当地** 扩大内部数组的容量。

得益于向量的封装，尽管扩容之后数据区的物理地址有所改变，却不致出现野指针。

至于适当地扩大，这里比较两种扩容策略：

`递增式扩容`：
进行 $n$ 次插入操作的时间复杂度为: $O(n^2)$，分摊复杂度为: $O(n)$，装填因子:
$\lambda \approx 100%$

`加倍式扩容`:
进行 $n$ 次插入操作的时间复杂度为: $O(n)$，分摊复杂度为: $O(1)$，装填因子：
$\lambda > 50%$

## 平均复杂度 vs. 分摊复杂度
`平均复杂度或期望复杂度（average/expected complexity）`

根据数据结构的各种操作出现概率的分布，将对应的成本加权平均
>* 各种可能的操作，作为**独立**事件分别考查
>* 割裂了操作之间的**相关性**和**连贯性**
>* 往往不能准确地评判数据结构和算法的真实性能

`分摊复杂度（amortized complexity）`

对数据结构**连续**地实施**足够多**次操作，所需总成本分摊到单次操作
>* 从实际可行地角度，对一系列操作做整体地考量
>* 更加忠实地刻画了可能出现地操作序列
>* 可以更为精准地评判数据结构和算法地真是性能

`比较`：
**平均复杂度** 有着以下的缺点：
假定各种输入实例的出现符合某种概率分布

不考虑加权平均的各种情况出现的次序

甚至所做的概率分布假定与实际不符

**分摊时间复杂度**：
各种操作之间存在前后连贯的时序关系，不割裂同一算法或数据结构的各次操作之间的因果关系。

更加关注整体的性能。

`例子`
若在采用加倍扩容策略中，假定采用均匀分布假设，以为扩容与不扩容事件的概率各半，则会得出
概率极低的错误结论。

对于递增式扩容以及加倍式扩容，在处于 $capacity = size = n$ 时单独一次的扩容操作，
所需地事件复杂度均为 $O(n)$。但是考虑到用户完成某个任务总共使用了足够多次的插入操作后
最终向量处于 $capacity = n$ 的状态，则递增扩容的分摊时间复杂度为 $O(n)$，而加倍扩容的
时间复杂度为 $O(1)$。

## 有序性
`有序性的必要条件`: 向量中的元素可以进行比较操作

`有序性的甄别`：**有序**/**无序** 序列中，**任意**/**总有** 一对相邻元素 **顺序**/**逆序**

`逆序程度`：相邻逆序对的数目

## 二分查找
`查找长度`：考查关键🐴的比较次数，即查找长度（search length）

`版本A`：成功失败的平均查找长度均大致为`O(1.50*logn)`

`改进思路`：由于向右查找所需的花费更多，所以通过左右的长度按照适当的比例进行平衡，从而使得向左更多地出现，向右更少地出现。这种减少更坏情况的出现是改进算法的一种很重要的思路。

`Fibonacci Search`:
<img src="https://latex.codecogs.com/gif.latex?$\alpha(\lambda)*log_2n&space;=&space;\lambda[1&plus;\alpha(\lambda)*log_2({\lambda&space;n})]&space;&plus;&space;(1-\lambda)[2&plus;\alpha(\lambda)*log_2((1-\lambda)n)]$" title="$\alpha(\lambda)*log_2n = \lambda[1+\alpha(\lambda)*log_2({\lambda n})] + (1-\lambda)[2+\alpha(\lambda)*log_2((1-\lambda)n)]$" />

整理后：
<img src="https://latex.codecogs.com/gif.latex?\frac{-ln2}{\alpha(\lambda)}&space;=&space;\frac{\lambda*ln&space;\lambda&plus;(1-\lambda)*ln(1-\lambda)}{2-\lambda}" title="\frac{-ln2}{\alpha(\lambda)} = \frac{\lambda*ln \lambda+(1-\lambda)*ln(1-\lambda)}{2-\lambda}" />

**
`另一中改进思路`：平衡左右分支转向代价，这种新的算法必须等到区间宽度收缩为1时才会退出，
最好的情况下性能有所倒退，但是在各种情况下的SL更加接近，整体性能更趋稳定。
